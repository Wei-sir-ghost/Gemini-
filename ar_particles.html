<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Particle Pro</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #0ff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #container { position: absolute; width: 100vw; height: 100vh; z-index: 1; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; }
        .status { font-size: 14px; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; }
        #gesture-hint { font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #0ff; }
        video { transform: scaleX(-1); position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0.3; filter: grayscale(1) brightness(0.5); }
    </style>
</head>
<body>
    <div id="ui">
        <div class="status" id="load-status">System: Initializing...</div>
        <div id="gesture-hint">Waiting for Hands...</div>
    </div>
    <video id="input-video" playsinline></video>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const PARTICLE_COUNT = 16000;
        let scene, camera, renderer, particles, geometry;
        let positions, velocities, targets;
        let gestureState = "SPHERE";
        let explosionStrength = 0;
        let handSpeed = 0;
        let lastHandPos = new THREE.Vector3();
        let isSystemReady = false;

        const loadStatus = document.getElementById('load-status');
        const gestureHint = document.getElementById('gesture-hint');
        const videoElement = document.getElementById('input-video');

        // --- 核心初始化 ---
        async function init() {
            // 1. Three.js 场景设置
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // 2. 粒子几何体配置
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            velocities = new Float32Array(PARTICLE_COUNT * 3);
            targets = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 20;
                positions[i3+1] = (Math.random() - 0.5) * 20;
                positions[i3+2] = (Math.random() - 0.5) * 20;
                // 默认形态：球体
                const p = getSpherePoint(3);
                targets[i3] = p.x; targets[i3+1] = p.y; targets[i3+2] = p.z;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                size: 0.04,
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 3. MediaPipe 配置
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });

            hands.onResults(onResults);

            const cameraHelper = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });

            loadStatus.innerText = "System: Camera Accessing...";
            try {
                await cameraHelper.start();
                loadStatus.innerText = "System: Active";
                isSystemReady = true;
            } catch (e) {
                loadStatus.innerText = "Error: Camera Denied";
                console.error(e);
            }

            animate();
        }

        // --- 形态生成器 ---
        function getSpherePoint(r) {
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
        }

        function getTorusPoint(r, tube) {
            const u = Math.random() * 2 * Math.PI, v = Math.random() * 2 * Math.PI;
            return { x: (r + tube * Math.cos(v)) * Math.cos(u), y: (r + tube * Math.cos(v)) * Math.sin(u), z: tube * Math.sin(v) };
        }

        function getHeartPoint(s) {
            const t = Math.random() * 2 * Math.PI;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            return { x: x * s * 0.15, y: y * s * 0.15, z: (Math.random()-0.5)*1.5 };
        }

        function getStarPoint(r) {
            const t = Math.random() * 2 * Math.PI, arms = 5, innerR = r * 0.4;
            const radius = (Math.floor(t / (Math.PI * 2 / 10)) % 2 === 0) ? r : innerR;
            return { x: radius * Math.cos(t), y: radius * Math.sin(t), z: (Math.random()-0.5)*1.5 };
        }

        function getTextPoints() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 400; canvas.height = 100;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 50px Arial';
            ctx.fillText('This is Gemini', 40, 65);
            const data = ctx.getImageData(0,0,400,100).data;
            const pts = [];
            for(let y=0; y<100; y+=2) for(let x=0; x<400; x+=2) if(data[(y*400+x)*4+3]>128) pts.push({x:(x-200)*0.04, y:(50-y)*0.04, z:(Math.random()-0.5)*0.5});
            return pts;
        }

        // --- 手势与物理 ---
        function changeGesture(type) {
            if (gestureState === type) return;
            gestureState = type;
            explosionStrength = 0.8; // 触发爆炸特效
            gestureHint.innerText = `Gesture: ${type}`;
            
            let pts = (type === "TEXT") ? getTextPoints() : [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let p;
                if(type === "SPHERE") p = getSpherePoint(3);
                else if(type === "TORUS") p = getTorusPoint(3, 0.8);
                else if(type === "HEART") p = getHeartPoint(1.5);
                else if(type === "STAR") p = getStarPoint(3.5);
                else p = pts[i % pts.length];
                targets[i3] = p.x; targets[i3+1] = p.y; targets[i3+2] = p.z;
            }
        }

        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
            const lm = results.multiHandLandmarks[0];

            // 1. 深度反馈
            const area = (Math.max(...lm.map(p => p.x)) - Math.min(...lm.map(p => p.x)));
            const targetScale = THREE.MathUtils.clamp(area * 6, 0.5, 3.0);
            particles.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);

            // 2. 挥手速度
            const currentPos = new THREE.Vector3(lm[9].x, lm[9].y, lm[9].z);
            handSpeed = currentPos.distanceTo(lastHandPos) * 150;
            lastHandPos.copy(currentPos);

            // 3. 手势识别
            const up = (tip, base) => lm[tip].y < lm[base].y;
            const count = [8, 12, 16, 20].filter(i => up(i, i-2)).length;
            const isThumb = lm[4].x < lm[3].x && lm[4].y < lm[2].y;

            if (count >= 4) changeGesture("SPHERE");
            else if (count === 2 && up(8, 6) && up(12, 10)) changeGesture("TEXT");
            else if (count === 0) changeGesture("TORUS");
            else if (count === 1 && up(8, 6)) changeGesture("STAR");
            else if (isThumb) changeGesture("HEART");
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!isSystemReady) return;

            const pos = geometry.attributes.position.array;
            const stiffness = 0.06;
            const damping = 0.9;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 加速度计算 (吸引力 + 干扰)
                let ax = (targets[i3] - pos[i3]) * stiffness;
                let ay = (targets[i3+1] - pos[i3+1]) * stiffness;
                let az = (targets[i3+2] - pos[i3+2]) * stiffness;

                const noise = explosionStrength + (handSpeed * 0.1);
                if (noise > 0.05) {
                    ax += (Math.random() - 0.5) * noise;
                    ay += (Math.random() - 0.5) * noise;
                    az += (Math.random() - 0.5) * noise;
                }

                // 物理叠加
                velocities[i3] = (velocities[i3] + ax) * damping;
                velocities[i3+1] = (velocities[i3+1] + ay) * damping;
                velocities[i3+2] = (velocities[i3+2] + az) * damping;

                pos[i3] += velocities[i3];
                pos[i3+1] += velocities[i3+1];
                pos[i3+2] += velocities[i3+2];
            }

            explosionStrength *= 0.95;
            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
